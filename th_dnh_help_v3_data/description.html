<HTML>
 <HEAD>
  <TITLE>Metodo di scrittura della sceneggiatura</TITLE>
  <META HTTP-EQUIV="Content-Type"CONTENT="text/html;charset=UTF-8">
  <META HTTP-EQUIV="Content-Type"CONTENT="text/css">
  <LINK rel="stylesheet" href="style.css" type="text/css">
 </HEAD>

 <STYLE TYPE="text/css">
  TABLE.tag {width:90%; vertical-align:top;background-color:RGB(255,255,255);border: 1px solid #cccccc;}
  TR.tag {}
  TD.tag_elementT {width:120px; background-color:#ffccff}
  TD.tag_valueT {width:120px; background-color:#ccccff}
  TD.tag_textT {background-color:#ccccff}
  TD.tag_element {vertical-align:top; width:120px; border: 1px solid #ffccff;}
  TD.tag_value {vertical-align:top; width:120px; border: 1px solid #ccccff;}
  TD.tag_text {vertical-align:top; border: 1px solid #ccccff;}
 </STYLE>

 <BODY link="#0000ff" alink="#0000ff" vlink="#0000ff">
 <DIV class="allbody">
 <SPAN class = "section_title">■Metodo di scrittura della sceneggiatura■</SPAN>
 <BR><BR>


 <SPAN class = "section_sub"><A name="Format">■Formattazione script</A></SPAN><BR>
 <P>Il formato del file di script può essere il seguente formato。<BR>
   Se più formati sono misti e si combinano i file utilizzando # include、<BR>
   Internamente converte tutto in Unicode e unisce i file。<BR>
    (Dal momento che il processo di conversione non necessario entra, funziona più
     velocemente se si unifica il formato a 1.)<BR>
  <TABLE class = "tag">
   <TR class = "tag">
    <TD class = "tag_elementT">Tipo</TD> <TD class = "tag_textT">Descrizione</TD>
   </TR>
   <TR class = "tag">
    <TD class = "tag_element">Shift-JIS</TD>
    <TD class = "tag_text">
      È un formato che può essere salvato selezionando SJIS o Shift-JIS con un editor di testo.<BR>
      (Prima di 0.12m o ph3 [.0], solo i file in questo formato potevano essere letti)<BR>
      Può essere visualizzato normalmente solo su Windows con impostazioni giapponesi.<BR>
    </TD>
   </TR>
   <TR class = "tag">
    <TD class = "tag_element">Unicode (UTF16LE)</TD>
    <TD class = "tag_text">
      È un formato che può essere salvato selezionando Unicode, UTF16, UTF16LE con un editor di testo.<BR>
         All'inizio del file è richiesto un BOM (Byte Order Mark).<BR>
            (Byte Order Mark viene solitamente aggiunto automaticamente da un editor di testo)<BR>
    </TD>
   </TR>
  </TABLE>
 </P>
 <BR><HR>


 <SPAN class = "section_sub"><A name="Header">■ Intestazione dello script</A></SPAN><BR>
 <P>L'intestazione dello script viene utilizzata per registrare il corpo principale in stile danmaku nel menu e per riconoscerlo come uno script di auto-macchina.<BR>
   Testo che appare all'inizio di uno script.<BR>
      È descritto con "#~~~" e ci sono i seguenti tipi.<BR>
  <TABLE class = "tag">
   <TR class = "tag">
    <TD class = "tag_elementT">Elemento</TD> <TD class = "tag_textT">Descrizione</TD>
   </TR>
   <TR class = "tag">
    <TD class = "tag_element">#Stile proiettile Touhou [xxx].</TD>
    <TD class = "tag_text">
      Scrivendo #東方弾幕風 o "#Touhou Danmaku Fuu", puoi registrarlo nel menu principale di Touhou Danmakufu.<BR>
         Inoltre, "#TouhouDanmakufu" ha lo stesso significato.<BR>
     <BR>
      Ci sono i seguenti tipi.<BR>
     ・#TouhouDanmakufu[Single]：Registrato nel menu come script unico.<BR>
     ・#TouhouDanmakufu[Plural]：Registrato nel menu come script di riproduzione continua.<BR>
     ・#TouhouDanmakufu[Stage]：Registrato nel menu come script di livello.<BR>
     ・#TouhouDanmakufu[Package]：Registrato nel menu come script di pacchetto.<BR>
     ・#TouhouDanmakufu[Player]：Registrato nell'engine come script giocatore.<BR>
    </TD>
   </TR>
   <TR class = "tag">
    <TD class = "tag_element">#ScriptVersion[3]</TD>
    <TD class = "tag_text">
      Indica la versione 3 dello script.<BR>
      è necessario perché deve riconoscre solo la versione 3 dello script.<BR>
    </TD>
   </TR>
   <TR class = "tag">
    <TD class = "tag_element">#ID["XXX"]</TD>
    <TD class = "tag_text">
      ID dello script.<BR>
      Utilizzato internamente per distinguere gli script.<BR>
      È meglio usare un nome che non corrisponda il più possibile ad altri script.<BR>
      Tuttavia questo codice è opzionale.<BR>
      Se omesso, verrà utilizzato il nome del file.<BR>
    </TD>
   </TR>
   <TR class = "tag">
    <TD class = "tag_element">#Title["XXX"]</TD>
    <TD class = "tag_text">
      Una stringa utilizzata per il titolo del menu.<BR>
    </TD>
   </TR>
   <TR class = "tag">
    <TD class = "tag_element">#Text["XXX"]</TD>
    <TD class = "tag_text">
      Una stringa utilizzata per la descrizione nel titolo del menu.<BR>
    </TD>
   </TR>
   <TR class = "tag">
    <TD class = "tag_element">#Image["XXX"]</TD>
    <TD class = "tag_text">
      Il percorso del file immagine utilizzato per le immagini del menu.<BR>
      Specifica un'immagine 640x480.<BR>
      È un percorso relativo dalla posizione del file eseguibile.<BR>
         Tuttavia, se scrivi "./" all'inizio del percorso come [./~], sarà un percorso relativo dalla cartella in cui si trova il file di script.<BR>
     <BR>
    Questo codice è opzionale<BR>
    </TD>
   </TR>
   <TR class = "tag">
    <TD class = "tag_element">#System["XXX"]</TD>
    <TD class = "tag_text">
      Percorso degli script di sistema.<BR>
         Nello script di sistema, punteggio, aerei rimanenti,vita nemica, ecc. vengono visu<BR>
     <BR>
      È un percorso relativo dalla posizione del file eseguibile.<BR>
         Tuttavia, se scrivi "./" all'inizio del percorso come [./~], sarà un percorso relativo dalla cartella in cui si trova il file di script.<BR>
     <BR>
     Tuttavia è opzionale.<BR>
      Se omesso「/script/default_system/Default_System.txt」vengono applicati gli script di sistema.<BR>
    </TD>
   </TR>
   <TR class = "tag">
    <TD class = "tag_element">#Background["XXX"]</TD>
    <TD class = "tag_text">
      Il percorso dello script in background.<BR>
      È un percorso relativo dalla posizione del file eseguibile.<BR>
         Tuttavia, se scrivi "./" all'inizio del percorso come [./~], sarà un percorso relativo dalla cartella in cui si trova il file di script.<BR>
     <BR>
    Opzionale.<BR>
      Se omesso, lo sfondo sarà nero.<BR>
     <BR>
      Internamente, questo percorso è usato solo per LoadScript→StartScript.<BR>
        Anche se lo ometti, lo sfondo verrà disegnato se crei il tuo script per lo sfondo andando su CaricaScript → StartScript.<BR>
    </TD>
   </TR>
   <TR class = "tag">
    <TD class = "tag_element">#BGM["XXX"]</TD>
    <TD class = "tag_text">
      Il percorso del file utilizzato per la musica di sottofondo. <BR>
        È un percorso relativo dalla posizione del file eseguibile. <BR>
        Tuttavia, se scrivi "./" all'inizio del percorso come [./~], sarà 
        un percorso relativo dalla cartella in cui si trova il file di script. <BR>
     <BR>
      Opzionale. <BR>
        Se omesso, sarà muto. <BR>
        Internamente utilizza solo questo percorso per riprodurre l'audio. <BR>
        Anche se lo ometti, la musica di sottofondo suonerà se suoni la tua voce. <BR>
    </TD>
   </TR>
   <TR class = "tag">
    <TD class = "tag_element">#Player["XXX","YYY",...]</TD>
    <TD class = "tag_text">
      Il percorso dello script della macchina che può essere utilizzato con questo script. <BR>
        Registra più dispositivi separati da ",". <BR>
        È un percorso relativo dalla posizione del file eseguibile. <BR>
        Tuttavia, se scrivi "./" all'inizio del percorso come [./~], sarà un percorso relativo dalla cartella in cui si trova il file di script. <BR>
     <BR>
      Opzionale. <BR>
        Se omesso, saranno disponibili tutti gli script self-machine in "/script/player/". <BR>
    </TD>
   </TR>
   <TR class = "tag">
    <TD class = "tag_element">#ReplayName["XXX"]</TD>
    <TD class = "tag_text">
      Questo è il nome dell'aereo per il replay. <BR>
        Specificare entro 8 caratteri. <BR>
    </TD>
   </TR>
  </TABLE>
 </P>
 <BR><HR>


 <SPAN class = "section_sub"><A name="Embedded">■ Routine incorporate</A></SPAN><BR>
  <P>Le routine integrate sono routine speciali descritte con "@XXX". <BR>
    Viene chiamato automaticamente dal corpo in stile danmaku in un momento specifico. <BR>
    Ci sono i seguenti tipi. <BR>

  <TABLE class = "tag">
   <TR class = "tag">
    <TD class = "tag_elementT">種類</TD> <TD class = "tag_textT">説明</TD>
   </TR>
   <TR class = "tag">
    <TD class = "tag_element">@Initialize</TD>
    <TD class = "tag_text">
      Chiamato solo una volta all'inizializzazione dello script. <BR>
        Chiamato appena prima che venga chiamato il primo @MainLoop. <BR>
    </TD>
   </TR>
   <TR class = "tag">
    <TD class = "tag_element">@Finalize</TD>
    <TD class = "tag_text">
      Chiamato solo una volta alla fine dello script.<BR>
    </TD>
   </TR>
   <TR class = "tag">
    <TD class = "tag_element">@MainLoop</TD>
    <TD class = "tag_text">
      Chiamato una volta per frame quando lo script è attivo.<BR>
    </TD>
   </TR>
   <TR class = "tag">
    <TD class = "tag_element">@Loading</TD>
    <TD class = "tag_text">
      Chiamato una volta per frame quando lo script è attivo.<BR>
        Inizializza in un altro thread.<BR>
     <BR>
      Può essere utilizzato solo per caricare trame e suoni,<BR>
        Si verifica un errore durante la creazione di un oggetto. <BR>
        Anche i numeri casuali non sono ammessi. <BR>
        (Poiché il tempo di esecuzione non può essere controllato, influisce sulla riproduzione del replay.)<BR>
    </TD>
   </TR>
   <TR class = "tag">
    <TD class = "tag_element">@Event</TD>
    <TD class = "tag_text">
      Chiamato quando si verifica un evento specifico.<BR>
     <A href = "description.html#Event">evento</A>Per favore riferisci a<BR>
    </TD>
   </TR>
  </TABLE>
 </P>
 <BR><HR>

 <SPAN class = "section_sub"><A name="Single">■Singolo script</A></SPAN><BR>
 <P>Script per la riproduzione di un colpo.<BR>
  È riconosciuto scrivendo "#Touhou Danmakufu [Single]" nella sceneggiatura.<BR>
    Normalmente, equivale alla carta incantesimo di un nemico.<BR>
      Di seguito è riportato un esempio di descrizione.<BR>
<DIV Class="source"><PRE class="source">
	#Touhou Danmakufu[Singolo]
	#ScriptVersion[<SPAN Class="source_number">3</SPAN>]
	#Title[<SPAN Class="source_string">"Segno zodiacale 「Fantasia di mezzanotte」"</SPAN>]
	#Text[<SPAN Class="source_string">"Prima Carta Incantesimo ExRumia: Segno Stellare「Fantasia di mezzanotte」"</SPAN>]
	#Image[<SPAN Class="source_string">"./img/ExRumia(Segno zodiacale「Fantasia di mezzanotte」).png"</SPAN>]
	#Background[<SPAN Class="source_string">"script/default_system/Default_Background_IceMountain.txt"</SPAN>]

	<SPAN Class="source_reserve">#include</SPAN><SPAN Class="source_string">"script/default_system/Default_ShotConst.txt"</SPAN>
	<SPAN Class="source_reserve">#include</SPAN><SPAN Class="source_string">"script/default_system/Default_Effect.txt"</SPAN>

	<SPAN Class="source_reserve">let</SPAN> objEnemy;
	<SPAN Class="source_reserve">let</SPAN> bConcentrationMotion = <SPAN Class="source_reserve">false</SPAN>;
	@Initialize
	{
		objEnemy = ObjEnemy_Create(OBJ_ENEMY_BOSS);
		ObjEnemy_Regist(objEnemy);
		ObjEnemy_SetDamageRate(objEnemy, <SPAN Class="source_number">10</SPAN>, <SPAN Class="source_number">10</SPAN>);<SPAN Class="source_comment">//Imposta il danno al 10%</SPAN>
		TWork;
		TRender;
		TEnd;

		DeleteShotAll(TYPE_ALL, TYPE_ITEM);<SPAN Class="source_comment">//Rimuove tutti i proiettili nemici non appena compaiono</SPAN>
	}

	@MainLoop
	{
		<SPAN Class="source_reserve">let</SPAN> ex = ObjMove_GetX(objEnemy);
		<SPAN Class="source_reserve">let</SPAN> ey = ObjMove_GetY(objEnemy);
		ObjEnemy_SetIntersectionCircleToShot(objEnemy, ex, ey, <SPAN Class="source_number">32</SPAN>);<SPAN Class="source_comment">//Imposta l'intersezione di sparo (proiettile automatico).</SPAN>
		ObjEnemy_SetIntersectionCircleToPlayer(objEnemy, ex, ey, <SPAN Class="source_number">24</SPAN>);<SPAN Class="source_comment">//Imposta l'intersezione del giocatore (colpo subito).</SPAN>

		<SPAN Class="source_reserve">yield</SPAN>;
	}

	@Event
	{
		<SPAN Class="source_reserve">alternative</SPAN>(GetEventType())
		<SPAN Class="source_reserve">case</SPAN>(EV_REQUEST_LIFE)
		{
			SetScriptResult(<SPAN Class="source_number">1500</SPAN>);<SPAN Class="source_comment">//Imposta la vita a 1500</SPAN>
		}
		<SPAN Class="source_reserve">case</SPAN>(EV_REQUEST_TIMER)
		{
			SetScriptResult(<SPAN Class="source_number">60</SPAN>);<SPAN Class="source_comment">//Imposta il limite di tempo a 60 secondi</SPAN>
		}
		<SPAN Class="source_reserve">case</SPAN>(EV_REQUEST_SPELL_SCORE)
		{
			SetScriptResult(<SPAN Class="source_number">30000</SPAN>);<SPAN Class="source_comment">//Imposta il bonus della carta incantesimo a 30000</SPAN>
		}
	}


	<SPAN Class="source_comment">//～～～Controllo del nemico</SPAN>

	<SPAN Class="source_comment">//----------------------------------------------------</SPAN>
	<SPAN Class="source_comment">//Compito in attesa di essere completato</SPAN>
	<SPAN Class="source_comment">//----------------------------------------------------</SPAN>
	<SPAN Class="source_reserve">task</SPAN> TEnd
	{
		<SPAN Class="source_reserve">while</SPAN>(ObjEnemy_GetInfo(objEnemy, INFO_LIFE) &gt; <SPAN Class="source_number">0</SPAN>)
		{
			<SPAN Class="source_reserve">yield</SPAN>;
		}

		<SPAN Class="source_reserve">let</SPAN> ex = ObjMove_GetX(objEnemy);
		<SPAN Class="source_reserve">let</SPAN> ey = ObjMove_GetY(objEnemy);
		TExplosionA(ex, ey, <SPAN Class="source_number">10</SPAN>, <SPAN Class="source_number">0.6</SPAN>);
		DeleteShotAll(TYPE_ALL, TYPE_ITEM);<SPAN Class="source_comment">//敵弾を全て削除	</SPAN>

		<SPAN Class="source_comment">//In caso di riproduzione continua, elimina il nemico,</SPAN>
		<SPAN Class="source_comment">//Procedi al passaggio successivo.</SPAN>
		<SPAN Class="source_comment">//Assicurati di eliminarlo.</SPAN>
		Obj_Delete(objEnemy);

		<SPAN Class="source_reserve">loop</SPAN>(<SPAN Class="source_number">30</SPAN>){<SPAN Class="source_reserve">yield</SPAN>;}

		<SPAN Class="source_comment">//Infine, chiudi lo script</SPAN>
		CloseScript(GetOwnScriptID());
	}

</PRE></DIV>
 </P>
 <BR><HR>


 <SPAN class = "section_sub"><A name="Plural">■Script di riproduzione continua</A></SPAN><BR>
 <P>Questo è uno script per la riproduzione continua.<BR>
    Si riconosce scrivendo 「#東方弾幕風[Plural]」 nella sceneggiatura.<BR>
    Di solito equivale a un boss nemico.BR>
    Di seguito è riportato un esempio di descrizione.<BR>
<DIV Class="source"><PRE class="source">
	#東方弾幕風[Plural]
	#ScriptVersion[<SPAN Class="source_number">3</SPAN>]
	#Title[<SPAN Class="source_string">"Riproduzione continua dello script Ex Rumia"</SPAN>]
	#Text[<SPAN Class="source_string">"Carta Magia Ex Rumia"</SPAN>]
	#Image[<SPAN Class="source_string">"./img/ExRumia(星符「ミッドナイトレヴァリエ」).png"</SPAN>]
	#Background[<SPAN Class="source_string">"script/default_system/Default_Background_IceMountain.txt"</SPAN>]

	@Initialize
	{
		TPlural();
	}

	@MainLoop
	{
		<SPAN Class="source_reserve">yield</SPAN>;
	}

	@Finalize
	{
	}


	<SPAN Class="source_reserve">task</SPAN> TPlural
	{
		<SPAN Class="source_reserve">let</SPAN> dir = GetCurrentScriptDirectory();

		<SPAN Class="source_comment">//Crea una scena con il boss.</SPAN>
		<SPAN Class="source_reserve">let</SPAN> obj = ObjEnemyBossScene_Create();
		ObjEnemyBossScene_Add(obj, <SPAN Class="source_number">0</SPAN>, dir ~ <SPAN Class="source_string">"ExRumia01.txt"</SPAN>);
		ObjEnemyBossScene_Add(obj, <SPAN Class="source_number">0</SPAN>, dir ~ <SPAN Class="source_string">"ExRumiaSpell01.txt"</SPAN>);
		ObjEnemyBossScene_LoadInThread(obj);
		ObjEnemyBossScene_Regist(obj);

		<SPAN Class="source_comment">//Aspetta finché la scena del boss nemico non finisce</SPAN>
		<SPAN Class="source_reserve">while</SPAN>(!Obj_IsDeleted(obj))
		{
			<SPAN Class="source_reserve">yield</SPAN>;
		}

		<SPAN Class="source_comment">//La sceneggiatura termina</SPAN>
		CloseScript(GetOwnScriptID());
	}
</PRE></DIV>
 </P>
 <BR><HR>


 <SPAN class = "section_sub"><A name="Stage">■Sceneggiatura dello Stage</A></SPAN><BR>
 <P>Questa è una sceneggiatura teatrale. (traduzione non corretta)<BR>
    Si riconosce scrivendo 「#東方弾幕風[Stage]」 nella sceneggiatura<BR>
    Di solito corrisponde a una fase.<BR>
    Di seguito è riportato un esempio di descrizione.<BR>
    <BR>
 <DIV Class="source"><PRE class="source">
	#東方弾幕風[Stage]
	#ScriptVersion[<SPAN Class="source_number">3</SPAN>]
	#Title[<SPAN Class="source_string">"Fase di prova EX Rumia"</SPAN>]
	#Text[<SPAN Class="source_string">"Fase di prova EX Rumia"</SPAN>]
	#Image[<SPAN Class="source_string">"./img/ExRumia(星符「ミッドナイトレヴァリエ」).png"</SPAN>]
	#Background[<SPAN Class="source_string">"script/default_system/Default_Background_IceMountain.txt"</SPAN>]

	@Initialize
	{
		TStage();
	}

	@MainLoop
	{
		<SPAN Class="source_reserve">yield</SPAN>;
	}

	@Finalize
	{
	}


	<SPAN Class="source_reserve">task</SPAN> TStage
	{
		<SPAN Class="source_reserve">let</SPAN> dir = GetCurrentScriptDirectory();

		<SPAN Class="source_comment">//ボス再生</SPAN>
		<SPAN Class="source_reserve">let</SPAN> path = dir ~ <SPAN Class="source_string">"ExRumia_Plural.txt"</SPAN>;
		<SPAN Class="source_reserve">let</SPAN> idScript = LoadScriptInThread(path);
		<SPAN Class="source_reserve">loop</SPAN>(<SPAN Class="source_number">60</SPAN>){<SPAN Class="source_reserve">yield</SPAN>;}<SPAN Class="source_comment">//1秒くらいあれば、コンパイル完了すると思われる。</SPAN>
		StartScript(idScript);

		<SPAN Class="source_comment">//敵ボスシーンが終了するまで待機</SPAN>
		<SPAN Class="source_reserve">while</SPAN>(!IsCloseScript(idScript))
		{
			<SPAN Class="source_reserve">yield</SPAN>;
		}

		<SPAN Class="source_comment">//～～～敵の出現やボスの出現を繰り返す。</SPAN>

		<SPAN Class="source_reserve">loop</SPAN>(<SPAN Class="source_number">240</SPAN>){<SPAN Class="source_reserve">yield</SPAN>;}

	    <SPAN Class="source_comment">//ステージ終了</SPAN>
		CloseStgScene();
	}
</PRE></DIV>
 </P>
 <BR><HR>


 <SPAN class = "section_sub"><A name="Player">■自機スクリプト</A></SPAN><BR>
 <P>自機スクリプトです。<BR>
    スクリプトに「#東方弾幕風[Player]」と記述することで自機用のスクリプトとして認識されます。<BR>
    以下に記述例を示します。<BR>
    <BR>
<DIV Class="source"><PRE class="source">
	#Image[<SPAN Class="source_string">"./ExRumiaImage.png"</SPAN>]


	<SPAN Class="source_reserve">let</SPAN> objPlayer = GetPlayerObjectID();
	<SPAN Class="source_reserve">let</SPAN> objSlowShot = ID_INVALID;
	<SPAN Class="source_reserve">let</SPAN> current = GetCurrentScriptDirectory();
	@Initialize
	{
		<SPAN Class="source_reserve">let</SPAN> path = current ~ <SPAN Class="source_string">"Default_Player_RumiaShotData.txt"</SPAN>;
		LoadPlayerShotData(path); <SPAN Class="source_comment">//自弾画像ロード</SPAN>

		ObjPlayer_AddIntersectionCircleA(objPlayer, <SPAN Class="source_number">0</SPAN>, <SPAN Class="source_number">0</SPAN>, <SPAN Class="source_number">1</SPAN>, <SPAN Class="source_number">20</SPAN>); <SPAN Class="source_comment">//当たり判定登録</SPAN>

		TImage();<SPAN Class="source_comment">//自機描画用タスク起動</SPAN>
		TShot();<SPAN Class="source_comment">//弾発射用タスク起動</SPAN>
		TMagicCircle();<SPAN Class="source_comment">//無敵時間魔法陣タスク起動</SPAN>
	}

	@MainLoop
	{
		<SPAN Class="source_reserve">yield</SPAN>;
	}

	@Finalize
	{
	}

	@Event
	{
		<SPAN Class="source_reserve">alternative</SPAN>(GetEventType())
		<SPAN Class="source_reserve">case</SPAN>(EV_REQUEST_SPELL)
		{
			<SPAN Class="source_comment">//スペルカード要求</SPAN>
			<SPAN Class="source_reserve">let</SPAN> spell = GetPlayerSpell();<SPAN Class="source_comment">//残りスペル数</SPAN>
			<SPAN Class="source_reserve">if</SPAN>(spell &gt;= <SPAN Class="source_number">1</SPAN>)
			{
				SetScriptResult(<SPAN Class="source_reserve">true</SPAN>);<SPAN Class="source_comment">//スペル発動可能</SPAN>
				SetPlayerSpell(spell-<SPAN Class="source_number">1</SPAN>);<SPAN Class="source_comment">//スペル数を1減らす</SPAN>
				TSpell();<SPAN Class="source_comment">//スペルタスク起動</SPAN>
			}
			<SPAN Class="source_reserve">else</SPAN>
			{
				SetScriptResult(<SPAN Class="source_reserve">false</SPAN>);<SPAN Class="source_comment">//スペル発動不可</SPAN>
			}
		}
		<SPAN Class="source_reserve">case</SPAN>(EV_HIT)
		{
			<SPAN Class="source_comment">//被弾</SPAN>
			TExplosion();
		}
		<SPAN Class="source_reserve">case</SPAN>(EV_PLAYER_REBIRTH)
		{
			<SPAN Class="source_comment">//復帰</SPAN>
			SetPlayerSpell(<SPAN Class="source_number">3</SPAN>);
			SetPlayerInvincibilityFrame(<SPAN Class="source_number">180</SPAN>);
		}
	}

	<SPAN Class="source_comment">//～～～省略</SPAN>
</PRE></DIV>
 </P>
 <BR><HR>


 <SPAN class = "section_sub"><A name="MenuScript">■メニュー系スクリプト</A></SPAN><BR>
 <P>一時停止中などに呼び出されるスクリプトで、<BR>
    メニュー系シーンのカスタマイズを行えます。<BR>
    サンプルは各デフォルトスクリプトを参照お願いします。<BR>
    <BR>
    いずれもSetScriptResultで特定の値を設定する必要があります。<BR>
    これらのスクリプトでは自機や弾などの操作を行うことはできません。<BR>
    <BR>
  <TABLE class = "tag">
   <TR class = "tag">
    <TD class = "tag_elementT">種類</TD> <TD class = "tag_textT">説明</TD>
   </TR>
   <TR class = "tag">
    <TD class = "tag_element">一時停止</TD>
    <TD class = "tag_text">
     一時停止(ポーズ)中に呼び出されるスクリプトです。<BR>
     システムスクリプト中で「SetPauseScriptPath」で使用スクリプトを設定します。<BR>
     デフォルトでは「/script/default_system/Default_Pause.txt」が使用されます。<BR>
     <BR>
     SetScriptResultに以下のいずれかを設定する必要があります。<BR>
     ・RESULT_CANCEL：再開<BR>
     ・RESULT_END：スクリプト：再生終了<BR>
     ・RESULT_RETRY：リトライ<BR>
    </TD>
   </TR>
   <TR class = "tag">
    <TD class = "tag_element">STGシーン終了</TD>
    <TD class = "tag_text">
     ゲームオーバーやステージクリア時に呼び出されます。<BR>
     デフォルトでは「/script/default_system/Default_EndScene.txt」が使用されます。<BR>
     <BR>
     SetScriptResultに以下のいずれかを設定する必要があります。<BR>
     ・RESULT_SAVE_REPLAY：リプレイ保存<BR>
     ・RESULT_END：スクリプト：再生終了<BR>
     ・RESULT_RETRY：リトライ<BR>
    </TD>
   </TR>
   <TR class = "tag">
    <TD class = "tag_element">リプレイ登録</TD>
    <TD class = "tag_text">
     リプレイ登録時に呼び出されます。<BR>
     デフォルトでは「/script/default_system/Default_ReplaySaveScene.txt」が使用されます。<BR>
     <BR>
     SetScriptResultに以下のいずれかを設定する必要があります。<BR>
     ・RESULT_CANCEL：キャンセル<BR>
     ・RESULT_END：リプレイ保存終了<BR>
    </TD>
   </TR>
  </TABLE>
 </P>
 <BR><HR>


 <SPAN class = "section_sub"><A name="ItemScript">■アイテムカスタムスクリプト</A></SPAN><BR>
  アイテムカスタムスクリプト内では、弾消しイベントやアイテム取得イベントを受けられます。<BR>
  アイテム操作用のスクリプトはStartItemScript関数で起動します。<BR>
  以下にアイテム動作カスタムスクリプトの記述例を示します。<BR>
	<DIV Class="source"><PRE class="source">
	@Initialize
	{
		<SPAN Class="source_comment">//弾削除時得点アイテム自動作成無効化</SPAN>
		SetDefaultBonusItemEnable(<SPAN Class="source_reserve">false</SPAN>);

		<SPAN Class="source_comment">//ユーザ定義アイテムデータ読み込み</SPAN>
		<SPAN Class="source_reserve">let</SPAN> dir = GetCurrentScriptDirectory();
		LoadItemData(dir ~ <SPAN Class="source_string">"ItemData.txt"</SPAN>)
	}

	@Event
	{
		<SPAN Class="source_reserve">alternative</SPAN>(GetEventType())
		<SPAN Class="source_reserve">case</SPAN>(EV_GET_ITEM)
		{
			<SPAN Class="source_comment">//アイテム取得イベント</SPAN>
			<SPAN Class="source_reserve">let</SPAN> itemType = GetEventArgument(<SPAN Class="source_number">0</SPAN>); <SPAN Class="source_comment">//アイテム種別取得</SPAN>
			<SPAN Class="source_reserve">let</SPAN> objItem = GetEventArgument(<SPAN Class="source_number">1</SPAN>); <SPAN Class="source_comment">//アイテムオブジェクト取得</SPAN>

			<SPAN Class="source_comment">//アイテム取得時処理</SPAN>
		}
		<SPAN Class="source_reserve">case</SPAN>(EV_DELETE_SHOT_TO_ITEM)
		{
			<SPAN Class="source_comment">//弾削除時アイテム作成イベント</SPAN>
			<SPAN Class="source_reserve">let</SPAN> objShot = GetEventArgument(<SPAN Class="source_number">0</SPAN>); <SPAN Class="source_comment">//オブジェクト取得</SPAN>
			<SPAN Class="source_reserve">let</SPAN> objPos = GetEventArgument(<SPAN Class="source_number">1</SPAN>); <SPAN Class="source_comment">//弾オブジェクト座標取得([0]=x, [1]=y)</SPAN>

			<SPAN Class="source_comment">//弾削除時アイテム作成処理</SPAN>
			TUserItem(objPos[<SPAN Class="source_number">0</SPAN>], objPos[<SPAN Class="source_number">1</SPAN>]);
		}
	}

	<SPAN Class="source_comment">//ユーザ定義アイテム作成</SPAN>
	<SPAN Class="source_reserve">task</SPAN> TUserItem(<SPAN Class="source_reserve">let</SPAN> itemX, <SPAN Class="source_reserve">let</SPAN> itemY)
	{
		<SPAN Class="source_reserve">let</SPAN> obj = CreateItemU1(<SPAN Class="source_number">1</SPAN>, itemX, itemY, <SPAN Class="source_number">10000</SPAN>);
		ObjItem_SetDefinedMovePatternA1(obj, ITEM_MOVE_TOPLAYER);
	}
	</PRE></DIV>
 <BR><HR>


 <SPAN class = "section_sub"><A name="ShotScript">■弾カスタムスクリプト</A></SPAN><BR>
  弾カスタムスクリプト内では、弾消しイベントなどを受けられます。<BR>
  スクリプトはStartShotScript関数で起動します。<BR>
  以下に弾動作カスタムスクリプトの記述例を示します。<BR>
	<DIV Class="source"><PRE class="source">
	@Initialize
	{
		<SPAN Class="source_comment">//弾消し(即消時)イベント有効</SPAN>
		SetShotDeleteEventEnable(EV_DELETE_SHOT_IMMEDIATE, <SPAN Class="source_reserve">true</SPAN>);
	}

	@Event
	{
		<SPAN Class="source_reserve">alternative</SPAN>(GetEventType())
		<SPAN Class="source_reserve">case</SPAN>(EV_DELETE_SHOT_IMMEDIATE)
		{
			<SPAN Class="source_comment">//弾消し時イベント有効</SPAN>
			<SPAN Class="source_reserve">let</SPAN> objShot = GetEventArgument(<SPAN Class="source_number">0</SPAN>); <SPAN Class="source_comment">//オブジェクト取得</SPAN>
			<SPAN Class="source_reserve">let</SPAN> objPos = GetEventArgument(<SPAN Class="source_number">1</SPAN>); <SPAN Class="source_comment">//弾オブジェクト座標取得([0]=x, [1]=y)</SPAN>

			<SPAN Class="source_comment">//弾消し時動作記載</SPAN>
		}
	}
	</PRE></DIV>
 <BR><HR>


 <SPAN class = "section_sub"><A name="PackageScript">■パッケージスクリプト</A></SPAN><BR>
 <P>タイトル画面、リプレイ一覧画面、ステージの連続再生など、<BR>
    すべての機能を作成するためのスクリプトです。<BR>
    <BR>
    パッケージスクリプト専用の関数は
    <A href="func_package.html#sec_package" target="right">パッケージスクリプト専用関数</A>
    を参照お願いします。<BR>
    <BR>
    記述方法は以下のサンプルスクリプトを参照お願いします。<BR>
    /script/ExRumia/ExRumia_Package_Main.txt<BR>
    <BR>
    実行ファイルをパッケージスクリプト再生専用にするには、「<A href="other_spec.html#Definition" target="right">定義ファイル(th_dnh.def)</A>」を参照お願いします。<BR>
    <BR>
 </P>
 <BR><HR>


 <SPAN class = "section_sub"><A name="Event">■イベント(@Event)</A></SPAN><BR>
 <P>@Eventは特定のタイミングで呼び出されます。<BR>
    イベントの種類は、「GetEventType」で取得できます。<BR>
    引数のあるイベントの場合は「GetEventArgument」で取得でき、<BR>
    返値が必要なイベントの場合は「SetScriptResult」で返値を設定します。<BR>

    <BR>
    組み込みのイベントには、以下の種類があります。<BR>

  <TABLE class = "tag">
   <TR class = "tag">
    <TD class = "tag_elementT">イベント種類</TD> <TD class = "tag_textT">説明</TD>
   </TR>
   <TR class = "tag">
    <TD class = "tag_element">EV_REQUEST_LIFE</TD>
    <TD class = "tag_text">
     敵ボスのライフの要求です。<BR>
     敵ボススクリプトのみで呼び出されます。<BR>
     <BR>
     real値を「SetScriptResult」で返す必要があります。<BR>
     要求された場合に無視するとエラーになります。<BR>
    </TD>
   </TR>
   <TR class = "tag">
    <TD class = "tag_element">EV_REQUEST_TIMER</TD>
    <TD class = "tag_text">
     敵ボスのタイマー要求です。<BR>
     敵ボススクリプトのみで呼び出されます。<BR>
     <BR>
     real値を「SetScriptResult」で返す必要があります。<BR>
     無視すると、無制限になります。<BR>
    </TD>
   </TR>
   <TR class = "tag">
    <TD class = "tag_element">EV_REQUEST_IS_LAST_SPELL</TD>
    <TD class = "tag_text">
     ラストスペル要求です。<BR>
     敵ボススクリプトのみで呼び出されます。<BR>
     <BR>
     boolean値を「SetScriptResult」で返す必要があります。<BR>
     無視すると、ラストスペルではなくなります。<BR>
    </TD>
   </TR>
   <TR class = "tag">
    <TD class = "tag_element">EV_REQUEST_IS_DURABLE_SPELL</TD>
    <TD class = "tag_text">
     耐久スペル要求です。<BR>
     敵ボススクリプトのみで呼び出されます。<BR>
     <BR>
     boolean値を「SetScriptResult」で返す必要があります。<BR>
     無視すると、耐久スペルではなくなります。<BR>
    </TD>
   </TR>
   <TR class = "tag">
    <TD class = "tag_element">EV_REQUEST_SPELL_SCORE</TD>
    <TD class = "tag_text">
     スペルカードスコア要求です。<BR>
     敵ボススクリプトのみで呼び出されます。<BR>
     <BR>
     boolean値を「SetScriptResult」で返す必要があります。<BR>
     無視すると、0点になります。<BR>
    </TD>
   </TR>
   <TR class = "tag">
    <TD class = "tag_element">EV_TIMEOUT</TD>
    <TD class = "tag_text">
     敵スペルのタイムアウト通知です。<BR>
     アクティブな全スクリプトに通知されます。<BR>
    </TD>
   </TR>
   <TR class = "tag">
    <TD class = "tag_element">EV_START_BOSS_SPELL</TD>
    <TD class = "tag_text">
     敵スペルカード開始通知です。<BR>
     アクティブな全スクリプトに通知されます。<BR>
    </TD>
   </TR>
   <TR class = "tag">
    <TD class = "tag_element">EV_GAIN_SPELL</TD>
    <TD class = "tag_text">
     スペルカード取得通知です。<BR>
     アクティブな全スクリプトに通知されます。<BR>
    </TD>
   </TR>
   <TR class = "tag">
    <TD class = "tag_element">EV_START_BOSS_STEP</TD>
    <TD class = "tag_text">
     ボスの1ステップ開始通知です。(Singleの1スクリプト相当開始通知です。)<BR>
     アクティブな全スクリプトに通知されます。<BR>
    </TD>
   </TR>
   <TR class = "tag">
    <TD class = "tag_element">EV_END_BOSS_STEP</TD>
    <TD class = "tag_text">
     ボスの1ステップ終了通知です。(Singleの1スクリプト相当終了通知です。)<BR>
     アクティブな全スクリプトに通知されます。<BR>
    </TD>
   </TR>
   <TR class = "tag">
    <TD class = "tag_element">EV_PLAYER_SHOOTDOWN</TD>
    <TD class = "tag_text">
     自機撃墜通知です。<BR>
     アクティブな全スクリプトに通知されます。<BR>
    </TD>
   </TR>
   <TR class = "tag">
    <TD class = "tag_element">EV_PLAYER_SPELL</TD>
    <TD class = "tag_text">
     自機スペル発動通知です。<BR>
     アクティブな全スクリプトに通知されます。<BR>
    </TD>
   </TR>
   <TR class = "tag">
    <TD class = "tag_element">EV_PLAYER_REBIRTH</TD>
    <TD class = "tag_text">
     自機復帰通知です。<BR>
     アクティブな全スクリプトに通知されます。<BR>
    </TD>
   </TR>
   <TR class = "tag">
    <TD class = "tag_element">EV_PAUSE_ENTER</TD>
    <TD class = "tag_text">
     一時停止開始通知です。<BR>
     アクティブな全スクリプトに通知されます。<BR>
     <BR>
     音声の停止操作などを想定しています。<BR>
     このイベント内では、乱数の使用、敵/弾オブジェクトの生成などSTGシーンに影響を与える処理は行わないでください。<BR>
     リプレイがずれます。<BR>
    </TD>
   </TR>
   <TR class = "tag">
    <TD class = "tag_element">EV_PAUSE_LEAVE</TD>
    <TD class = "tag_text">
     一時停止解除通知です。<BR>
     アクティブな全スクリプトに通知されます。<BR>
     <BR>
     音声の再開操作などを想定しています。<BR>
     このイベント内では、乱数の使用、オブジェクトの生成などSTGシーンに影響を与える処理は行わないでください。<BR>
     リプレイがずれます。<BR>
    </TD>
   </TR>
   <TR class = "tag">
    <TD class = "tag_element">EV_REQUEST_SPELL</TD>
    <TD class = "tag_text">
     自機スペル開始要求です。<BR>
     自機スクリプトのみで呼び出されます。<BR>
     <BR>
     boolean値を「SetScriptResult」で返す必要があります。<BR>
     スペルカードを呼び出せる場合にtrueを返します。<BR>
     要求された場合に無視するとエラーになります。<BR>
    </TD>
   </TR>
   <TR class = "tag">
    <TD class = "tag_element">EV_GRAZE</TD>
    <TD class = "tag_text">
     かすり通知です。<BR>
     自機スクリプトのみで呼び出されます。<BR>
     <BR>
     かすりのエフェクトや効果音を再生するのに使用します。<BR>
     GetEventArgument(0)：前フレームのかすり回数(real)<BR>
     GetEventArgument(1)：前フレームのかすった弾IDのリスト(real配列)<BR>
     GetEventArgument(2)：前フレームのかすった弾座標のリスト(real配列[index][x, y])<BR>
    </TD>
   </TR>
   <TR class = "tag">
    <TD class = "tag_element">EV_HIT</TD>
    <TD class = "tag_text">
     撃墜通知です。<BR>
     自機スクリプトのみで呼び出されます。<BR>
     <BR>
     自機の撃墜エフェクトや効果音を再生するのに使用します。<BR>
     GetEventArgument(0)：自機に当たった敵／弾ID(real)<BR>
    </TD>
   </TR>
   <TR class = "tag">
    <TD class = "tag_element">EV_GET_ITEM</TD>
    <TD class = "tag_text">
     アイテム取得通知です。<BR>
     自機スクリプト、アイテムスクリプトのみで呼び出されます。<BR>
     <BR>
     GetEventArgument(0)でどのアイテムを取得したかを確認できます。<BR>
	・ITEM_POWER：パワーアップアイテム<BR>
	・ITEM_POWER_S：パワーアップアイテム(小)<BR>
	・ITEM_SPELL：スペル(ボム)アイテム<BR>
	・ITEM_SPELL_S：スペル(ボム)アイテム(小)<BR>
	・ITEM_POINT：点アイテム<BR>
	・ITEM_POINT_S：点アイテム(小)<BR>
     <BR>
     GetEventArgument(1)でアイテムオブジェクトのIDを取得できます。<BR>
    </TD>
   </TR>
   <TR class = "tag">
    <TD class = "tag_element">EV_DELETE_SHOT_IMMEDIATE</TD>
    <TD class = "tag_text">
     敵弾の削除通知です。<BR>
     弾動作カスタムスクリプトで呼び出されます。<BR>
     弾動作カスタムスクリプトでのイベント通知は、<BR>
     　SetShotDeleteEventEnable(EV_DELETE_SHOT_IMMEDIATE, true);<BR>
     を呼び出すと有効になります。<BR>
     <BR>
     GetEventArgument(0)で弾オブジェクトのIDを取得できます。<BR>
     GetEventArgument(1)で弾座標を取得できます。(real配列 [x, y])<BR>
    </TD>
   </TR>
   <TR class = "tag">
    <TD class = "tag_element">EV_DELETE_SHOT_TO_ITEM</TD>
    <TD class = "tag_text">
     敵弾のアイテム化通知です。<BR>
     アイテム動作カスタムスクリプトで呼び出されます。<BR>
     <BR>
     GetEventArgument(0)で弾オブジェクトのIDを取得できます。<BR>
     GetEventArgument(1)で弾座標を取得できます。(real配列 [x, y])<BR>
    </TD>
   </TR>
   <TR class = "tag">
    <TD class = "tag_element">EV_DELETE_SHOT_FADE</TD>
    <TD class = "tag_text">
     敵弾のフェード削除通知です。<BR>
     弾動作カスタムスクリプトで呼び出されます。<BR>
     弾動作カスタムスクリプトでのイベント通知は、<BR>
     　SetShotDeleteEventEnable(EV_DELETE_SHOT_FADE, true);<BR>
     を呼び出すと有効になります。<BR>
     <BR>
     GetEventArgument(0)で弾オブジェクトのIDを取得できます。<BR>
     GetEventArgument(1)で弾座標を取得できます。(real配列 [x, y])<BR>
    </TD>
   </TR>
  </TABLE>

  <BR>
    独自にイベントを通知したい場合は「NotifyEvent」もしくは「NotifyEventAll」関数を呼び出します。<BR>
    その場合のイベント種別は、以下の値を使用してください。<BR>
  <TABLE class = "tag">
   <TR class = "tag">
    <TD class = "tag_elementT">イベント種類</TD> <TD class = "tag_textT">説明</TD>
   </TR>
   <TR class = "tag">
    <TD class = "tag_element">EV_USER_SYSTEM</TD>
    <TD class = "tag_text">
     システムスクリプト用のユーザ定義イベント値です。<BR>
     EV_USER_SYSTEM～EV_USER_SYSTEM + EV_USER_COUNT までの値を指定できます。<BR>
    </TD>
   </TR>
   <TR class = "tag">
    <TD class = "tag_element">EV_USER_STAGE</TD>
    <TD class = "tag_text">
     ステージ(敵)スクリプト用のユーザ定義イベント値です。<BR>
     EV_USER_STAGE～EV_USER_STAGE + EV_USER_COUNT までの値を指定できます。<BR>
    </TD>
   </TR>
   <TR class = "tag">
    <TD class = "tag_element">EV_USER_PLAYER</TD>
    <TD class = "tag_text">
     自機スクリプト用のユーザ定義イベント値です。<BR>
     EV_USER_PLAYER～EV_USER_PLAYER + EV_USER_COUNT までの値を指定できます。<BR>
    </TD>
   </TR>
   <TR class = "tag">
    <TD class = "tag_element">EV_USER_PACKAGE</TD>
    <TD class = "tag_text">
     パッケージスクリプト用のユーザ定義イベント値です。<BR>
     EV_USER_PACKAGE～EV_USER_PACKAGE + EV_USER_COUNT までの値を指定できます。<BR>
    </TD>
   </TR>
   <TR class = "tag">
    <TD class = "tag_element">EV_USER</TD>
    <TD class = "tag_text">
     ユーザ定義イベント値です。<BR>
     EV_USER～EV_USER + EV_USER_COUNT までの値を指定できます。<BR>
    </TD>
   </TR>
  </TABLE>

 </P>
 <BR><HR>

 </DIV></BODY>
</HTML>
